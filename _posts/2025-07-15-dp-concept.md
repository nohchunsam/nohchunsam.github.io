---
title: 동적 계획법 - 최장 증가 부분 수열, 최장 공통 부분 수열
date: 2025-07-16 13:59:00 +0900
categories: 코딩테스트
tags: ["코딩 테스트", "알고리즘", "C++", "공부"]
---

코딩 테스트 문제 중 유독 동적 계획법을 못해서... 기본적인 문제라도 분석해 개념을 제대로 익히고자 한다.

해당 글은 전체적으로 《코딩 테스트 합격자 되기 C++》 를 참고했다.
몇몇 문제의 스포일러가 있으니 원치 않은 사람은 뒤로 가자.

## 개념
**큰 문제를 작은 부분 문제로 나누어 해결하고, 그 결과를 활용해 큰 문제를 해결하는 방법이다.**
바텀 업과 비슷하게 작은 문제를 해결하고, 그 해결을 좀 더 큰 문제에 적용해 해결하는 방식이다. 
단, 동적 계획법은 나누었을 때 **작은 문제들이 같아야 하고 반복돼야 한다.** 그래야 이전에 해결했던 문제를 다른 문제에 적용할 수 있다.

### 점화식

> 점화식: 수열에서 이웃하는 두 개의 항 사이에 성립하는 관계를 나타내는 관계식이다. `a[n+1] = a[n] + 2` 같은 식이다.


그 때문에 동적 계획법은 주로 점화식을 세우고 시작한다. 《코딩 테스트 합격자 되기 C++》에서는 다음과 같이 점화식을 세우고 동적 기법을 풀라고 한다.

1. 해가 이미 있다고 가정 (=해를 가진 함수가 있다고 가정)
2. (함수의) 종료 조건 설정
  - 여기서 **어떻게 함수를 표현하고**, **어떻게 문제를 쪼개는지**도 정한다.
3. 1.과 2. 를 활용해 점화식 세우기


### 예시

책에서는 예로 팩토리얼 계산을 든다.
1. Fact(N)이 N!을 반환한다고 가정
2. Fact(N)의 종료 조건을 설정한다.
  - Fact(N) = N*Fact(N-1)이다.
  - Fact(N)은 N이 1일때 종료하고 그 값을 반환한다.
3. 1.과 2.를 활용해 점화식을 세운다.
  - Fact(N) = N*Fact(N-1)
  - Fact(1) = 1

이런 식으로 점화식을 세워 동적 계획법 문제를 해결한다.

### 메모이제이션

단, 이 점화식을 재귀로 풀 경우, 수가 크면 함수 호출 정보도 그만큼 쌓이게 된다. 이를 조금이라도 줄이기 위해 **메모이제이션**을 사용한다.

> 메모이제이션: 재귀 호출을 줄이기 위해 사용한다. 이미 계산한 값을 저장해뒀다가 이후 쓸 일이 있을 때 활용하는 개념.
작은 문제들의 값을 저장해둔 후, 큰 문제를 해결해야할 때 관련된 문제의 값이 있다면 그걸 꺼내 사용한다.

그러나 본 책에서는 메모이제이션을 재귀 횟수 줄이는데 사용하는 게 아닌 부분 문제를 저장해 다른 문제를 푸는데 사용된다. 구체적인 사용은 문제를 통해 설명하려고 한다.

## 1. 최장 증가 부분 수열 LIS
최장 증가 부분 수열은
- 최장 증가: 오름차순을 유지하면서도 길이가 가장 긴
- 부분 수열: 기존 수열의 수를 (순서를 유지한 채로) 뽑은 수열
이다.

다음과 같은 수열이 있다면
```
1 4 2 3 1 5
```
아래와 같은 수열이 위 수열의 최장 증가 부분 수열이다.
```
1   2 3   5
```

이제 점화식을 세워보자.

### 1. 해가 이미 있다고 가정 (=해를 가진 함수가 있다고 가정)

주어진 수열에서 최장 증가 부분 수열의 수를 반환하는 함수 `dp(int arr[])`가 있다고 가정하자.

### 2. (함수의) 종료 조건 설정
위에서 이야기했듯 여기서 **어떻게 함수를 표현하고**, **어떻게 문제를 쪼개는지**도 정한다.

가장 쉬운 방법은 arr의 각 원소를 기준으로 최장 부분 수열을 구하는 것이다.

즉, arr[0]을 마지막으로 하는 최장 부분 수열을 구하고, arr[1]을 마지막으로 하는 최장 부분 수열을 구하고, ... arr[n-1]을 마지막으로 하는 최장 부분 수열을 구해 그 중 가장 긴 것을 반환하면 된다.

```
[1]                         arr[0]을 마지막으로 하는 lis 길이 = 1
[1] [4]                     arr[1]을 마지막으로 하는 lis 길이 = 2
[1]  4  [2]                 arr[2]을 마지막으로 하는 lis 길이 = 2
[1]  4  [2]  [3]            arr[3]을 마지막으로 하는 lis 길이 = 3
[1]  4   2    3   [1]       arr[4]을 마지막으로 하는 lis 길이 = 2
[1]  4  [2]  [3]   1  [5]   arr[5]을 마지막으로 하는 lis 길이 = 4
```

#### 예) arr[1]을 마지막으로 하는 lis 길이
이때 arr[1]을 마지막으로 하는 lis 길이를 구하는 법을 생각해보자.

arr[0]을 마지막으로 하는 lis 길이는 -자신 외에는 다른 수가 없으므로- 1이다. arr[1]은 lis를 구할 때 이전에 구한 arr[0]을 마지막으로 하는 lis 길이를 참고한다.

```
[1]                         arr[0]을 마지막으로 하는 lis 길이 = 1
[1] 4
```
이제 오름차순을 유지하면서도 길이가 가장 긴 수열을 찾기 위해 이전 lis를 참고하자.
- arr[0]을 마지막으로 하는 lis 길이: arr[0]은 arr[1]보다 작다. 현재 lis 길이보다 크므로 1로 갱신한다.

이외에는 없다. 최장이 arr[0]을 마지막으로 하는 lis이므로 그에 arr[1]의 원소를 추가해 길이를 늘려, arr[1]을 마지막으로 하는 lis 길이는 2가 된다.


#### 예) arr[3]을 마지막으로 하는 lis 길이
또 다른 예를 들어보자.

```
[1]                         arr[0]을 마지막으로 하는 lis 길이 = 1
[1] [4]                     arr[1]을 마지막으로 하는 lis 길이 = 2
[1]  4  [2]                 arr[2]을 마지막으로 하는 lis 길이 = 2
1    4   2   3
```

arr[3]=3이다. 이때도 오름차순을 유지하면서 가장 길이가 큰 수열이 있는지 찾아보자. 우선 현재 lis 길이를 0이라고 하자.

- arr[0]을 마지막으로 하는 lis 길이: arr[0]은 arr[3]보다 작다. 현재 lis 길이보다 크므로 1로 갱신한다.
- arr[1]을 마지막으로 하는 lis 길이: arr[1]은 arr[3]보다 크다.
- arr[2]을 마지막으로 하는 lis 길이: arr[2]은 arr[3]보다 작다. 현재 lis 길이보다 크므로 2로 갱신한다.

조건을 만족하는 현재까지 구한 lis 길이는 'arr[2]을 마지막으로 하는 lis 길이'다. 이에 arr[3]을 마지막으로 하는 길이는 구한 것에 1을 더해 3이 된다.

이런 식으로 arr의 모든 원소를 마지막으로 하는 lis를 구하면, 종료하면 된다.

### 3. 1.과 2. 를 활용해 점화식 세우기

어느정도의 규칙성이 보인다. 이를 통해 다음과 같은 식을 세울 수 있다.

```
lis[0...n-1] 일 때,

lis[0] = 1
lis[k] = max(lis[i]) + 1 (단, i < k 이고 arr[i] <= arr[k])

dp(int arr[]) = max(lis[0...n-1])
```

이제 lis를 구한 뒤 그 중 제일 크기가 큰 수를 반환하면 된다.

## 2. 최장 공통 부분 수열 LCS
또 다른 문제를 풀어보자. 최장 공통 부분 수열은
- 최장 공통: 같은 원소를 가지면서도 가장 긴
- 부분 수열: 기존 수열의 순서로 뽑은 수열이다.

+) 수열이라고 썼지만 원문은 subsequence이기 때문에, 여기서는 문자열이라고 한다.

다음과 같은 문자열이 있다면,
```
A   B   C   D   F
B   D   F   C
```
아래와 같이 `B D F`가 최장 공통 부분 문자열이다.
```
    B       D   F
B   D   F   
```
### 1. 해가 이미 있다고 가정 (=해를 가진 함수가 있다고 가정)
주어진 두 문자열에서 최장 공통 부분 수열의 수를 반환하는 `dp(char arr1[], char arr2[])`가 있다고 하자.

### 2. (함수의) 종료 조건 설정

우선 일치해야하므로 arr1의 원소 하나를 기준으로 arr2의 모든 원소를 살핀다. 

```
arr1:  A   B   C   D   F
arr2:  B   D   F   C
```

살피는 과정은 다음과 같다.
1. arr1의 A가 arr2의 원소 중 일치하는 게 있는지 살핀다. 없으므로 넘어간다.
2. arr1의 B가 arr2의 원소 중 일치하는 게 있는지 살핀다. 있다. 
  - 순서를 유지하기 위해 arr1[1] 이전에, 그리고 arr2[0] 이전에 구한 lcs의 길이가 있는지 확인한다.
  - 없다. 현재 최장 길이: 0+1 = 1
3. arr1의 C가 arr2의 원소 중 일치하는 게 있는지 살핀다. 있다.
  - arr1[2] 이전에, arr2[3] 이전에 구한 lcs 길이가 있는지 확인한다.
  - 2.에서 구한 게 있다. 현재 최장 길이: 1+1 = 2.
4. arr1의 D가 arr2의 원소 중 일치하는 게 있는지 살핀다. 있다.
  - arr1[3] 이전에, arr2[1] 이전에 구한 lcs 길이가 있는지 확인한다.
  - 1., 2.가 있다. 더 길이가 큰 2를. 택한다.
  - 3.에서 구한 것은 현재 범위를 벗어나므로 고려하지 않는다. (고려하면 순서가 어긋난다.)
  - 현재 최장 길이: 1+1 = 2
5. arr1의 C가 arr2의 원소 중 일치하는 게 있는지 살핀다. 있다.
  - arr1[4] 이전에, arr2[2] 이전에 구한 lcs 길이가 있는지 확인한다.
  - 1., 2., 4., 가 있다. 그 중 길이가 가장 긴 4.를 택한다.
  - 현재 최장 길이: 2+1 = 3

이런 식으로 구할 수 있다. 

단 각 문자열의 원소별로 길이를 체크해줘야하기 때문에 일치하지 않을 때도 고려해야 한다. 이를 위해 2중 배열로, 일치하지 않을 경우 그 이전에 구했던 lcs 중 가장 큰 걸 택한다.

### 3. 1.과 2.를 활용해 점화식 세우기
이를 바탕으로 식을 세우면 다음과 같다.
```
lcs[0...n-1][0...m-1] (lcc[i][j] = arr1[0...i]와 arr[0...j]까지의 lcs)

if arr1[i] == arr2[j]:
  lcs[i][j] = lcs[i-1][j-1] + 1 // 이전까지 구한 최장 lcs
else:
  lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1])
```
---

정리하며 느낀거지만 동적 계획법은 아이디어 싸움인 것 같다. 어떻게 쪼갤지를 어떻게 표현하는 게 제일 관건인 것 같다... 아이디어가 없는 사람은 많이 보기라도 해야지.