---
title: EP 5. 레지스터
date: 2025-09-01 12:12:00 +0900
categories: CS
tags: ["CS", "컴퓨터 구조"]
---

[참고 영상](https://youtu.be/sWuGTRnZ63I?si=c_UIXhpxHcDXk1Ac)


이 영상에서는 SR 래치를 데이터 플립플롭을 만들고, 또 데이터 플립플롭을 레지스터로 만드는 방법을 설명한다.

## 레지스터란?

입력과 메모리는 컴퓨터의 정보 자원이다. 그 중 **메모리**는 프로그램이나 프로그램의 중간 단계 결과를 저장한다. 하지만 메모리는 직접 접근하기에는 너무 느리다! 그래서 **프로세서는 메모리에서 필요한 값을 가지고 와, 빠르게 접근할 수 있는 임시 저장소에 저장하고, 필요할 때마다 꺼내 쓴다.** 바로 이 빠르게 접근할 수 있는 저장소가 **레지스터**다.

![](img/computer-architecture/fast_temporary_storage.png)

레지스터는 다른 용도로도 사용된다. 예로 프로그램 카운터Program Counter(Instruction Pointer)는 다음에 실행될 명령instruction이 어디인지 알려주는 용도로 사용된다.

앞서 설명했든듯 레지스터는 **데이터 플립플롭**으로 구성된다. 이 **데이터 플립플롭을 만들기위해 SR 래치를 D 래치로 만들어야한다.**

## D 래치

![](img/computer-architecture/d_latch.png)

> Data 래치를 줄여 D 래치라고 한다.

게이트 SR 래치는 R, S, Clk까지 총 3개의 입력이 필요했지만 여기서는 **D와 Clk 총 2개의 입력으로 회로를 구성**한다. 이 역시 Clk가 1일 때에만 Q 값이 변한다.

SR 래치에서 S와 R 둘 다 0이거나, 두 값이 정반대여야 했다. D 래치에서는 이걸 Not 게이트를 사용해 해결한다. 즉 D가 1이면 Set은 1, Reset은 0이 된다.

이제 D 래치 구조를 알았으니 데이터 플립플롭을 만들 수 있다.

## 플립플롭이란?

래치는 **제어 신호의 상태에** 따라 결과가 달라진다. SR 래치의 경우 Set과 Reset에 따라 결과가 달라지고, D 래치는 D와 Clk의 값에 따라 결과가 달라진다.

플립플롭은 **제어 신호의 변화에** 따라 결과가 달라진다. 제어 신호가 0에서 1로 바뀔 때, 아니면 0에서 1로 바뀔 때 결과가 달라진다.

> 이를 edge-triggered라고 한다. 0에서 1로, 1에서 0으로 바뀔 때를 **가장자리edge**라고 한다.

데이터 플립플롭의 경우 일반적으로 제어 신호가 상승(0→1) 또는 하강(1→0)할 때 저장 값을 변경한다. 

> 한 시스템의 모든 플립플롭은 같은 타이밍에 변경한다. 시스템에 있는 플립플롭이 상승할 때 변경한면 나머지 플립플롭도 상승할 때 변경한다.

**입력은 제어 신호가 변할 때에만 안정적이면 된다.** 이 때문에 실제 조합 회로가 안정화되는데 시간이 걸린다.

> 클럭Clock: 위에 있던 Clk는 전부 클럭을 의미한다. 클럭은 0, 1이 반복되는 신호를 생성한다. 이 신호의 속도는 기계마다 다르고, 빠를수록 CPU의 성능이 좋다.

### 오버클럭Overclock

컴퓨터 성능에서는 회로가 작업을 할 때 시간이 얼마나 걸리는지가 관건이다. 
오버클럭은 클럭 속도를 정해진 속도보다 더 빠르게 실행시켜, 새로운 레지스터 상태를 저장하게 한다. 이를 통해 더 많은 작업을 수행할 수 있다.

## D 플립플롭

![](img/computer-architecture/d_flip_flop.png)

두 개의 D 래치를 연결해 만들 수 있다. Clk 값이 변할 때 결과값이 변경된다.

### Combinational Loop

출력이 다음 출력에 영향을 끼치는 구조를 의미한다. 예를 들어 출력값을 입력값으로 계속해서 사용하는 경우, 입력값이 계속 변화해 출력도 불안정해진다. [참고글1](https://wh00300.tistory.com/220), [참고글2](https://www.intel.com/content/www/us/en/docs/programmable/683323/18-1/avoid-combinational-loops.html)

![](img/computer-architecture/combinaitional_loop.png)

플립플롭은 위와 같은 문제를 해결해준다. Clk가 입력과 출력의 경계 역할을 해준다. 입력도 출력도 클럭이 바뀔 때에만 갱신돼 다음 클락까지의 값을 보존할 수 있다.

### Clear & Enable Signals

플립플롭의 상태를 **초기화clear 해** 이상한 값을 가지지 않도록 해야하고, **어떤 클록 엣지(상승/하강)에 값을 저장할지 제어enable**할 수 있어야 한다. 이것들은 D 플롭 회로에 별도의 신호와 게이트를 추가해 이뤄진다.

![](img/computer-architecture/clear_rest_flip_flop.png)

### Clear와 Rest의 차이

동영상에서, Reset은 플립플롭의 동기적 0 설정이며 Clear은 플립플롭의 비동기적 0 설정이라고 한다.

- 동기적: 클럭이 토글될=값이 바뀔 때만 0으로 설정
- 비동기적: 클리어 신호가 1일 때 0으로 설정 (클럭과 별개)

이젠 D 플립플롭 8개를 합쳐 8bit 레지스터를 만들 수 있다!

## 레지스터 + AU
  
레지스터와 연산 유닛이 어떻게 연결되는지 설명한다. 한 프로세서 당 총 네 개의 레지스터를 가지게 된다.

- A, B: 프로그램이 필요한 모든 데이터를 저장
- PC: Program Couner
- O: Operand Register (명령에서 사용하는 값)

## 멀티플렉서

연산 중 4개의 입력 중 2개를 선택해야 하는 경우가 있다. 이 경우 멀티플렉서를 사용한다. 4x1 멀리플렉서의 경우, 2비트 제어 신호를 기반해 네 개의 가능한 입력에서 하나를 택한다.

![](img/computer-architecture/multiplexer.png)

> 영상에서 우측 스위치에 따라 레지스터에 들어오는 불이 달라지는 걸 확인할 수 있다.

## 전체 구조

![](img/computer-architecture/register.png)

enable 신호를 clk과 clear 신호와 별개로 두기위해 split merge 모듈로 연결한다.

> 8bit 레지스터를 만들기위해 4bit 레지스터를 4개씩 연결했다... 이것저것 찾아봤지만 아직도 왜인지는 이해를 못했다. 나중에 알게되면 축하력 한다...

위에서 4개의 레지스터가 필요하다고 했다. 이걸 전부 연결하면 다음과 같다.

![](img/computer-architecture/whole_architecture.png)

우측 하단에 멀티플렉서가 있는데, 이건 O 레지스터의 0 비트를 1비트로 만든데 사용된다. 어디에서 사용되는지는 추후에 설명한다고 한다.