---
title: EP 8. 데이터 패스
date: 2025-09-03 14:04:00 +0900
categories: CS
tags: ["CS", "컴퓨터 구조"]
---

[참고 영상](https://youtu.be/Cd7yej5PNOA?si=iaJktg3KCW6rFIMa)

우리는 지금까지 프로세서의 핵심 구성들(ALU, 레지스터, 메모리, 멀티플렉서)을 알아봤다!

이제 이것들이 어떻게 함께 구성되는지 알아보려고 한다.

프로세서는 개념적으로는 **데이터 패스**, **제어 패스** 총 두 개의 패스Path를 가지고 있다.

## 데이터 패스

- 실질적 처리Process가 이루어진다. 레지스터에서 데이터를 저장하고, 연산을 하고, 다시 레지스터에 결과를 저장하고, 레지스터값을 메모리에 저장한다.
- 데이터패스는 프로그램의 명령이 어디까지 실행됐는지 확인한다.
- 일종의 루프를 형성한다.
  1. 데이터를 가지고 와 레지스터에 저장한다.
  2. 메모리와 ALU가 레지스터의 데이터를 가지고 와 새로운 값을 만든다.
  3. 멀티플렉서가 어떤 값을 1.의 레지스터에 저장할지 결정한다.

데이터 패스는 많은 신호들을 처리한다. 이 모든 신호들을 제어 신호라고 한다. 이 신호로 데이터 패스가 각 클록마다 데이터 경로가 무엇을 할지 결정한다.

## 실행의 세 단계

![](img\computer-architecture\data_path1.png)

이 프로세서에서는 총 세 가지의 단계를 거쳐 처리가 일어난다.

1. Fetch: 메모리에서 현재 명령을 읽는다. <br/>PC에서 명령을 가지고 와, AU와 멀티플렉서를 통해 주소를 계산한다. OP Code에 저장된다.
2. PC 증가: 프로그램 카운터를 1 증가시켜 다음 명령을 가리키도록 한다.
3. 실행: 현재 명령을 실행한다. <br/>메모리에서 필요한 데이터를 가져오고, 명령에 필요한 것을 만들기위해 제어 신호를 설정한다.

## 전체 구조

전체 프로세서는 다음과 같다.

![](img\computer-architecture\data_path2.png)

![](img\computer-architecture\data_path3.png)

1. ALU
2. 멀티플렉서: 아래의 레지스터에서 값을 선택한다.
3. 레지스터
4. 메모리
5. 논리 연산
6. 논리 연산의 멀티플렉서: 언제 프로그램 카운터를 갱신할지 제어 </br> 2단계, 3단계에 있거나, 조건없는 브랜치 명령, 조건 브랜치의 조건이 충족될 때 갱신된다.
7. 멀티플렉서: and 게이트로 사용됨
8. 멀티플렉서: 해당 멀티플렉서의 출력은 메모리를 읽을지 말지 결정함
9. 신호 분리기: 메모리, A 레지스터, B 레지스터 중 어느 레지스터에 값을 쓸지 결정함
10. 프로그램 카운터
11. O 레지스터: 명령을 메모리에서 가져올 때 사용됨
12. ALU: 프로그램 카운터를 1 증가시키기위한 덧셈 유닛
13. 멀티플렉서: 데이터 패스에서 프로그램 카운터로 값을 쓸지 결정할 수 있음 (조건 브랜치, 점프 명령에 사용됨)

## O 레지스터

> Operand 레지스터의 약자다.

명령을 메모리에서 로드할 때 명령어가 높은 니블(high nibble)과 낮은 니블(nibble)로 나뉜다.

> 니블: 4-bit = 1/2bytes

- 낮은 니블: 명령어의 **오퍼랜드(operand)**. 데이터 경로 내에서 사용될 작은 숫자. O 레지스터의 낮은 비트로 감
- 높은 니블: **오퍼레이션 코드(opcode)**가 되어 어떤 명령어인지 알려주며, 4비트로 16가지 가능한 명령어를 가질 수 있다.

## 수동 제어

이하 영상에서는 프로세서를 수동으로 제어해 어떻게 신호가 오가는지 보여준다. . . 어려운 내용이지만 한번은 보는 걸 추천한다.