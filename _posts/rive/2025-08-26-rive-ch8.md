---
title: Rive 튜토리얼 - Ch.8 레이아웃
date: 2025-08-26 14:19:00 +0900
categories: Rive
tags: ["Rive", "공부"]
---

## 8.1 레이아웃 개요 Introduction To Layouts

- 레이아웃은 스크린 사이즈, 데이터에 대해 동적으로 조정하는 컨테이너를 의미한다!
- 예로, Row나 Column을 통해 객체들을 배열할 수 있다.
- 상태머신을 통해 Row나 Column 안에 있는 객체들의 순서와 위치를 실시간으로 변경할 수 있다.
- 이 레이아웃을 앱/웹에 적용해 디자인을 실시간으로 변경시킬 수 있다.

## 8.2 로우와 컬럼 Rows and Columns

- 둘을 통틀어 레이아웃이라고 부른다.

- 객체들을 선택하고 `Shift` + `L` 을 누르면 자동으로 레이아웃을 설정한다.

![](img/rive_ch8/layout_panel.png)

> 로우/컬럼 자동 감싸기는 여러 개의 객체를 선택할 때만 적용된다. 객체를 하나만 선택해서 단축키를 누르면 단일 레이아웃만 생성된다.

- 또는 위의 버튼을 통해 추가할 수 있다.

![](img/rive_ch8/layout_hierarchy.png)


- 레이아웃을 설정한 경우, 각 객체들도 레이아웃으로 감싸진다.
- 객체마다의 레이아웃을 통해 위치와 크기를 계산할 수 있게 된다.
- 또한 객체를 애니메이션하기 위해, 레이아웃과 객체를 분리해놨다. 즉, 애니메이션으로 객체의 위치를 바꿔도 레이아웃과 무관해진다.
- 레이아웃으로 감싸지지 않은 객체를 칼럼, 로우 같은 레이아웃에 집어넣으면 배치와 무관하게 위치된다/위치할 수 있다.

### 인스펙터

![](img/rive_ch8/layout_inspector.png)

- W와 H 아래에 있는 Hug는 안에 있는 객체들을 전부 감쌀 수 있는 크기를 의미한다.
- 아래의 정사각형: 아트보드 끝과의 거리를 조절
- 컬럼에서 로우, 로우에서 컬럼으로 변경 가능
- 패딩, 마진 추가 가능
- 둥근 모서리 가능
- 배경, 전경 색이나 테두리 설정 가능
- 레이아웃 안에 있는 것들은 자식처럼 움직인다. 즉, 레이아웃이 안에 있는 객체/레이아웃의 부모다. 

## 8.3 동적으로 바뀌는 버튼 Dynamically Changing Buttons

텍스트 크기에 맞춘 버튼을 만드는 방법이다. 실습에 가깝다...

![](img/rive_ch8/dynamic_button.png)

- 텍스트를 레이아웃-로우로 감싸고, 그 로우에 색과 패딩을 넣는다.
- 그림자가 될 색은 페더Feather를 설정하고, Y 오프셋을 아래로 설정하면 된다.

> 6.10 장에서 만들었던 것과 비슷한 기능을 한다. 하지만 간단하기는 이쪽이 훨씬 간단하다!!

# 8.4 요소 크기 맞추기 Fitting Elements

![](img/rive_ch8/box_example.png)

- 위와 같은 걸 하나 만들어준다. 검은 배경과 둥근 모서리는 content에서 설정한다.
- viewport 레이아웃에서, 절대Absolute를 끄면 넓이와 높이를 채우기Fill로 설정할 수 있다.
- content도 그렇게 설정한다.
- 이후 content를 복사 붙여넣기를 하면, 각 content가 같은 비율의 높이를 차지하게 된다.

![](img/rive_ch8/box_example2.png)

- viewport에서 패딩과 간격을 설정할 수 있다.

![](img/rive_ch8/box_example3.png)

- 이미지는 위에서 만든 각 content들의 넓이를 다르게 설정한 것이다.
- fixed px: 넓이를 고정 픽셀로 설정. 부모=viewport의 넓이가 변해도 영향를 받지 않는다.
- fixed %: 넓이를 고정 비율로 설정. 부모=viewport의 넓이가 변하면 영향을 받는다. (넓이에 맞는 비율로 늘어나거나 줄어든다.)
- hug: 넓이를 허그hug로 설정. 자식들의 크기에 맞춘다. 텍스트의 길이가 늘어나면 그에 맞춰 넓이가 변한다. 부모=viewport의 넓이가 변해도 영향을 받지 않는다.
- fill: 넓이를 채우기fill로 설정. 부모의 넓이에서 최대한 차지한다. 부모=viewport의 넓이가 변하면 영향을 받는다. (넓이에 맞는 비율로 늘어나거나 줄어든다.)
  - fill로 설정된 것 중 하나만 크기를 키우고 싶으면 넓이에서 1fr의 수를 높이면 된다. 
  - 1fr 비율 또한 애니메이팅이 가능하다. 즉, 상태 머신 전환에서도 사용할 수 있다.

![](img/rive_ch8/box_example4.png)

> 이 영상에서 새로운 기능을 언급만 하고 쓱 넘어갔다. Any State와 각 전환들을 잇고 > 모든 화살표들을 선택 > 우클릭 > Create Condition > Number 1 > Left to Right를 하면 왼쪽에 있는 전환부터 0에서 시작해 순차적으로 조건을 자동 생성한다.

## 8.5 동적인 요소로 리플로우하기 Reflow With Dynamic Components

스크린이나 아트보드의 크기에 따라 레이아웃을 변경하는 법에 대해 설명한다만... 영상 자체가 실습에 가깝다. 몇가지 팁만 작성한다.

> 리플로우: 브라우저 렌더링 과정에서 레이아웃 배치를 다시 계산하는 행위

- 중간에 레이아웃 추가하기: 위의 페널에서 추가하거나 하이어라키의 레이아웃 아무거나 복사해 안의 객체 제거하면 된다
- 정렬 예외 만들기: 우측 상단으로 배열돼 있는 것을, 맨 아래에 있는 객체는 하단에 배치하고 싶을 경우 별도의 레이아웃을 만들어 공간을 만든다
- 허그: 허그는 부모의 배치보다 안의 요소의 크기를 더 우선 순위로 둔다. 부모의 배치를 생각하면 채우기Fill로 변경
- 중첩된 아트보드: 중첩된 아트보드를 통해 현 아트보드/레이아웃을 기준으로 배치할 수 있다
- 애니메이션: 레이아웃의 로우, 컬럼, 배치, 고정, 허그 등 전부 애니메이팅할 수 있다.
- 비율을 기준으로 전환: 전환에 사용하는 변수로 아트보드의 넓이, 높이, 비율을 설정할 수 있다.

## 8.6 레이아웃 방향 Layout Direction

![](img/rive_ch8/layout_direction.png)

- 레이아웃에 있는 객체들의 순서, 글씨의 배치를 바꿀 수 있다.

left to right

![](img/rive_ch8/left_to_right.png)

right to left

![](img/rive_ch8/right_to_left.png)

- 애니메이션 모드에서 키 프레임을 찍는 것도 가능하다