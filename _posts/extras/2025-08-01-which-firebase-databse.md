---
title: 파이어베이스 데이터베이스 뭐 쓰지
date: 2025-08-01 10:34:00 +0900
categories: 기타
tags: ["Firebase"]
---

앱에 서버를 붙이려고 한다. 근데 진짜 뭐 쓰지. 

모르겠으니 Cloud Firestore랑 Realtime Database를 우선 비교해보려고 한다.

# 공식 문서: Cloud Firestore vs Realtime Database

[공식 문서](https://firebase.google.com/docs/firestore/rtdb-vs-firestore?hl=ko)에 이렇게 적혀 있긴 하다.

> - **Cloud Firestore**는 *권장*되는 엔터프라이즈급 JSON 호환 문서 데이터베이스로, 250,000명이 넘는 개발자가 신뢰하고 있습니다. 쿼리 가능성, 확장성 및 고가용성이 필요한 풍부한 데이터 모델을 갖춘 애플리케이션에 적합합니다. 또한 지연 시간이 짧은 클라이언트 동기화와 오프라인 데이터 액세스를 제공합니다.
- **Realtime Database**는 기본 Firebase JSON 데이터베이스입니다. 간단한 조회와 확장성이 제한적이며 지연 시간이 짧은 동기화가 필요한 단순한 데이터 모델을 사용하는 애플리케이션에 적합합니다.

비교하라고 표도 만들어줬다. 요약하자면 이렇다.

| 비교 | Cloud Firestore | Realtime Database |
| ------------ | ------------------ | ------------------ | 
| 데이터 모델 | JSON과 유사한 문서 컬렉션<br>대규모에 적합 | JSON 트리<br>단순한 데이터에 적합 | 
| 실시간 및 오프라인 지원 | Apple, Android, 웹 | Apple, Android | 
| 접속 상태 | 지원 X | 지원 O | 
| 쿼리 | 복합 정렬 및 필터링 | 제한적인 정렬 및 필터링 | 
| 쓰기 및 트랜잭션 | 고급 쓰기 및 트랜잭션 | 기본 쓰기 및 트랜잭션 | 
| 안정성 및 성능 | 문서 개별의 안정성<br>30ms 이하의 응답 시간 | 상위 노드의 규칙은<br> 하위 노드에도 적용<br>10ms 이하의 응답 시간 |
| 업타임 | 높음<br>가용성 면에서는 더 유리 | 높음 |
| 확장성 | 확장이 자동으로 수행 | 샤딩을 사용해야함 |
| 보안성 | 승인과 검증이 결합된 비단계식 규칙 | 승인과 검증이 분리된 단계식 규칙 언어 |
| 가격 책정 | 읽기, 쓰기, 삭제 횟수<br>+ 대역폭 + 저장용량 | 대역폭 + 저장용량 |

좀 노골적으로 Cloud Firestore를 밀고 있다. 하지만 아직 제대로 알기 힘든 게 많다. 차례차례 정리해보자.

# 데이터 모델

## Cloud Firestore

저장 단위는 문서다. 문서에 대한 설명은 다음과 같다.

> 문서가 JSON과 매우 비슷해졌는데, 사실 기본적으로는 JSON과 유사합니다. 문서가 추가적인 데이터 유형을 지원하고 크기가 1MB로 제한되는 등의 몇 가지 차이점이 있기는 하지만, 일반적으로는 문서를 간단한 JSON 레코드로 취급해도 무방합니다.

### 데이터 유형

데이터 유형으로는 배열, 불리안, 바이트, 날짜 및 시간, 부동 소수점 수(float, double), 지리적 지점, 정수, 맵, Null, 경로, 텍스트 문자열, 벡터가 있다.

Realtime Databse보다는 훨씬 많은 자료형을 제공한다.

### 컬렉션

근데 자료형이 많은 걸 제외하고는 JSON과 여전히 같다. 하지만 차이라면 차이라고 할 수 있는게 있는데, 문서를 저장하는 자료형 컬렉션이 있다.

컬렉션은 단순히 문서를 저장하는 용도로 쓰인다.

> Cloud Firestore는 스키마를 사용하지 않으므로 각 문서에 어떤 필드를 넣을지와 각 필드에 어떤 유형의 데이터를 저장할지는 완전히 사용자의 재량입니다. 같은 컬렉션에 포함된 여러 문서가 서로 다른 필드를 포함하거나 이러한 필드에 서로 다른 유형의 데이터를 저장할 수도 있습니다. 그러나 문서를 보다 쉽게 쿼리할 수 있도록 여러 문서에서 동일한 필드와 데이터 유형을 사용하는 것이 좋습니다.

> 컬렉션은 오로지 문서만 포함합니다. 값이 있는 원시 필드를 직접 포함하거나 다른 컬렉션을 포함할 수 없습니다. Cloud Firestore에서 보다 복잡한 데이터를 구조화하는 방법은 계층적 데이터를 참조하세요.

그러니 사용자 정보만 가지고 오고 싶은 경우, 사용자 컬렉션에서 문서를 가져오면 된다는 것이다.

## RealtTime Database

모든 데이터는 JSON 객체로 저장된다. 

JSON이 기본적으로 가질 수 있는 데이터 유형 정수, 부동 소수점 수, 문자열, 불리안, 객체(맵), 배열, null을 가질 수 있다.

> Cloud Firestore, Realtime Database 둘 다 JSON 구조를 공유하고 있으므로, 데이터를 분리해 효율적으로 다운로드할 수 있도록 해야한다. 또한 구조에 따라 확장성이 달라진다. 이러나 둘 다 처음에 어떻게 설계하냐가 매우 중요하다.

# 실시간 및 오프라인 지원

네트워크가 끊겨도 정상 작동하도록 하는 기능이다.

네트워크가 중단되면 Firebase 앱이 이를 감지하고, 우선 가져온 데이를 사용한다. 네트워크에 다시 연결되면 Firebase에 현재까지의 상태를 쓴다.

>Firebase 앱은 일시적인 네트워크 중단을 자동으로 처리합니다. 오프라인 상태에서는 캐시된 데이터를 사용할 수 있고, 네트워크 연결이 복원되면 Firebase에서 모든 쓰기 작업을 다시 전송합니다.

> 디스크 지속성을 사용 설정하면 앱의 데이터를 기기에 로컬로 저장하므로 오프라인 상태일 때도 앱이 현재 상태를 유지할 수 있으며, 사용자 또는 운영체제가 앱을 다시 시작하더라도 유지됩니다.

# 쿼리

## Cloud Firestore

`where()` 메서드는 비교 연산자를 지원한다. 이외에도 `array-contains`, `array-contains-any`, `in`, `not-in` 등 배열이나 필드에 대한 검색도 가능하게 해준다.

## RealtTime Database

주로 첫번째나 마지막 데이터를 기준으로 가져오거나, 시작 및 종료 지점을 선택해 데이터를 가져온다.  정확히 일치하는 항목을 필터링할 수 있고, 또 하위 데이터, 키, 값을 통해 정렬할 수도 있다.

다만 Cloud Firestore와 비교했을 때, 사용할 수 있는 쿼리가 단순하다.

# 쓰기 및 트랜잭션

## Cloud Firestore

### 쓰기

기본적인 읽고 쓰기 외에도 배열 요소를 업데이트할 수 있다.

> 문서에 배열 필드가 포함되어 있으면 `arrayUnion()` 및 `arrayRemove()`를 사용해 요소를 추가하거나 삭제할 수 있습니다. `arrayUnion()`은 배열에 없는 요소만 추가하고, `arrayRemove()`는 제공된 각 요소의 모든 인스턴스를 삭제합니다.

숫자 값을 원하는만큼 늘리거나 줄일 수도 있다.

### 트랜잭션

여러 문서에 대해 원자성을 보장한다. (단, 많은 문서를 일괄로 쓰면 트랜잭션 크기 한도를 초과할 수 있다...)

여러 문서의 복잡한 관계를 업데이트하는데 사용할 수 있다.

## RealtTime Database

쓰기 자체는 기본적이다.

### 트랜잭션

선택한 단일 노드와 그 하위 노드에 대한 원자성을 보장한다. 즉, 사용자1에 접근하면 그와 같은 단계의 사용자2는 별도의 트랜잭션이 필요하다.

> 트랜잭션은 둘 다 충돌 발생 시 재시도를 하고, 읽기가 먼저 선행되야 한다는 건 같다.

# 업타임

> 동작 중이면서 사용 가능한 기계(일반적으로 컴퓨터)의 시간을 백분율로 나타낸 시스템의 신뢰성의 측정이다 - 위키백과

>시간은 컴퓨터가 그대로 두었을 대 충돌 없이, 관리나 유지보수 목적으로 재부팅 필요성 없이 동작할 수 있는 시간을 말한다. -위키백과

둘 다 업타임은 높다. Cloud Firestore가 근소한 차로 조금 더 높다고 한다.

# 확장성

## Cloud Firestore

자동으로 확장된다. 개발자가 직접 분할할 필요 없이 서비스를 제공할 수 있다.

## Realtime Database

샤딩을 해야한다. 개발자가 추가적으로 데이터베이스를 수정해야 한다.

> 샤딩이란 데이터베이스 또는 테이블을 수평으로 분할해 저장하는 것을 의미한다. 이러면 데이터베이스의 확장성과 성능을 향상시킬 수 있다.

# 가격 책정

## Cloud Firestore

- 저장 크기: 5GB까지는 무료, 이후 1GB 당 0.026달러
- 다운로드: 하루에 1GB까지는 무료, 이후 1GB 당 0.12달러
- 업로드: 하루에 20,000회까지는 무료, 이후 10,000회 당 0.05달러
- 다운로드: 하루에 50,000회까지는 무료, 이후 10,000회 당 0.004달러

> 스토리지 및 대역폭 사용량은 기가바이트(GiB)로 계산되며, 1GiB = 230바이트입니다. 모든 요금은 일 단위로 누적됩니다.

| 무료 등급 | 할당량 |
| -------- | ----- |
| 저장된 데이터	| 1GiB |
| 문서 읽기	50,000/일 |
| 문서 쓰기	20,000/일 |
| 문서 삭제	20,000/일 |
| 아웃바운드 데이터 전송 | 10GiB/월 |

- 쓰기와 삭제는 한번 할때마다 1회로 계산된다.
- 최대 1000개의 색인 항목을 읽을 때마다 읽기 작업이 1회의 요금이 부과된다. 집계 쿼리도 마찬가지다.
- 저장 비용은 GiB/월 단위로 매일 계산된다.

## Realtime Database

- 1GB는 무료, 이후 1GB 당 5달러
- 달에 10GB 다운로드는 무료, 이후 1GB 당 1달러

-----------------

여러모로 알아봤는데... 데이터의 저장 자체는 컨테이너를 제공한다는 점에서 Cloud Firestore를 사용할 것 같다. 당장 사용자 수도 없으니 무료 플랜으로 충분할 것 같다는 생각도 든다.

다만 내 앱의 경우 이미지도 저장해야하는데, 이 경우에는 Firebase Storage나 다른 서버를 사용하라는 추천을 받았다. 아무래도 저장 크기 때문이 제일 크다!! (애초에 Cloud Firestore나 Realtime이나 이미지 저장하라고 만든 것은 아니다.)

이것들을 고려했을 때 Cloud Firestore와 Storage를 같이 쓸 것 같다. Storage는 나중에 한번 알아보자...